// automatically generated by the FlatBuffers compiler, do not modify
// swiftlint:disable all
// swiftformat:disable all

#if canImport(Common)
import Common
#endif

import FlatBuffers

public enum Eppo_UFC_UFCFormat: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case server = 0
  case client = 1

  public static var max: Eppo_UFC_UFCFormat { return .client }
  public static var min: Eppo_UFC_UFCFormat { return .server }
}


public enum Eppo_UFC_VariationType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case boolean = 0
  case integer = 1
  case json = 2
  case numeric = 3
  case string = 4

  public static var max: Eppo_UFC_VariationType { return .string }
  public static var min: Eppo_UFC_VariationType { return .boolean }
}


public enum Eppo_UFC_AlgorithmType: Int8, Enum, Verifiable {
  public typealias T = Int8
  public static var byteSize: Int { return MemoryLayout<Int8>.size }
  public var value: Int8 { return self.rawValue }
  case constant = 0
  case contextualBandit = 1

  public static var max: Eppo_UFC_AlgorithmType { return .contextualBandit }
  public static var min: Eppo_UFC_AlgorithmType { return .constant }
}


public struct Eppo_UFC_Range: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case start = 4
    case end = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var start: Int32 { let o = _accessor.offset(VTOFFSET.start.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var end: Int32 { let o = _accessor.offset(VTOFFSET.end.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public static func startRange(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(start: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: start, def: 0, at: VTOFFSET.start.p) }
  public static func add(end: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: end, def: 0, at: VTOFFSET.end.p) }
  public static func endRange(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createRange(
    _ fbb: inout FlatBufferBuilder,
    start: Int32 = 0,
    end: Int32 = 0
  ) -> Offset {
    let __start = Eppo_UFC_Range.startRange(&fbb)
    Eppo_UFC_Range.add(start: start, &fbb)
    Eppo_UFC_Range.add(end: end, &fbb)
    return Eppo_UFC_Range.endRange(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.start.p, fieldName: "start", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.end.p, fieldName: "end", required: false, type: Int32.self)
    _v.finish()
  }
}

public struct Eppo_UFC_Shard: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case salt = 4
    case ranges = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var salt: String? { let o = _accessor.offset(VTOFFSET.salt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var saltSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.salt.v) }
  public var hasRanges: Bool { let o = _accessor.offset(VTOFFSET.ranges.v); return o == 0 ? false : true }
  public var rangesCount: Int32 { let o = _accessor.offset(VTOFFSET.ranges.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func ranges(at index: Int32) -> Eppo_UFC_Range? { let o = _accessor.offset(VTOFFSET.ranges.v); return o == 0 ? nil : Eppo_UFC_Range(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startShard(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(salt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: salt, at: VTOFFSET.salt.p) }
  public static func addVectorOf(ranges: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: ranges, at: VTOFFSET.ranges.p) }
  public static func endShard(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createShard(
    _ fbb: inout FlatBufferBuilder,
    saltOffset salt: Offset = Offset(),
    rangesVectorOffset ranges: Offset = Offset()
  ) -> Offset {
    let __start = Eppo_UFC_Shard.startShard(&fbb)
    Eppo_UFC_Shard.add(salt: salt, &fbb)
    Eppo_UFC_Shard.addVectorOf(ranges: ranges, &fbb)
    return Eppo_UFC_Shard.endShard(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.salt.p, fieldName: "salt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.ranges.p, fieldName: "ranges", required: false, type: ForwardOffset<Vector<ForwardOffset<Eppo_UFC_Range>, Eppo_UFC_Range>>.self)
    _v.finish()
  }
}

public struct Eppo_UFC_Split: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case variationKey = 4
    case shards = 6
    case extraLogging = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var variationKey: String? { let o = _accessor.offset(VTOFFSET.variationKey.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var variationKeySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.variationKey.v) }
  public var hasShards: Bool { let o = _accessor.offset(VTOFFSET.shards.v); return o == 0 ? false : true }
  public var shardsCount: Int32 { let o = _accessor.offset(VTOFFSET.shards.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func shards(at index: Int32) -> Eppo_UFC_Shard? { let o = _accessor.offset(VTOFFSET.shards.v); return o == 0 ? nil : Eppo_UFC_Shard(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var hasExtraLogging: Bool { let o = _accessor.offset(VTOFFSET.extraLogging.v); return o == 0 ? false : true }
  public var extraLoggingCount: Int32 { let o = _accessor.offset(VTOFFSET.extraLogging.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func extraLogging(at index: Int32) -> Eppo_UFC_StringPair? { let o = _accessor.offset(VTOFFSET.extraLogging.v); return o == 0 ? nil : Eppo_UFC_StringPair(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startSplit(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(variationKey: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: variationKey, at: VTOFFSET.variationKey.p) }
  public static func addVectorOf(shards: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: shards, at: VTOFFSET.shards.p) }
  public static func addVectorOf(extraLogging: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: extraLogging, at: VTOFFSET.extraLogging.p) }
  public static func endSplit(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createSplit(
    _ fbb: inout FlatBufferBuilder,
    variationKeyOffset variationKey: Offset = Offset(),
    shardsVectorOffset shards: Offset = Offset(),
    extraLoggingVectorOffset extraLogging: Offset = Offset()
  ) -> Offset {
    let __start = Eppo_UFC_Split.startSplit(&fbb)
    Eppo_UFC_Split.add(variationKey: variationKey, &fbb)
    Eppo_UFC_Split.addVectorOf(shards: shards, &fbb)
    Eppo_UFC_Split.addVectorOf(extraLogging: extraLogging, &fbb)
    return Eppo_UFC_Split.endSplit(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.variationKey.p, fieldName: "variationKey", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.shards.p, fieldName: "shards", required: false, type: ForwardOffset<Vector<ForwardOffset<Eppo_UFC_Shard>, Eppo_UFC_Shard>>.self)
    try _v.visit(field: VTOFFSET.extraLogging.p, fieldName: "extraLogging", required: false, type: ForwardOffset<Vector<ForwardOffset<Eppo_UFC_StringPair>, Eppo_UFC_StringPair>>.self)
    _v.finish()
  }
}

public struct Eppo_UFC_Variation: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case key = 4
    case value = 6
    case algorithmType = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var key: String! { let o = _accessor.offset(VTOFFSET.key.v); return _accessor.string(at: o) }
  public var keySegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.key.v) }
  public var value: String? { let o = _accessor.offset(VTOFFSET.value.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var valueSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.value.v) }
  public var algorithmType: Eppo_UFC_AlgorithmType { let o = _accessor.offset(VTOFFSET.algorithmType.v); return o == 0 ? .constant : Eppo_UFC_AlgorithmType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .constant }
  public static func startVariation(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(key: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: key, at: VTOFFSET.key.p) }
  public static func add(value: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: value, at: VTOFFSET.value.p) }
  public static func add(algorithmType: Eppo_UFC_AlgorithmType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: algorithmType.rawValue, def: 0, at: VTOFFSET.algorithmType.p) }
  public static func endVariation(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
  public static func createVariation(
    _ fbb: inout FlatBufferBuilder,
    keyOffset key: Offset,
    valueOffset value: Offset = Offset(),
    algorithmType: Eppo_UFC_AlgorithmType = .constant
  ) -> Offset {
    let __start = Eppo_UFC_Variation.startVariation(&fbb)
    Eppo_UFC_Variation.add(key: key, &fbb)
    Eppo_UFC_Variation.add(value: value, &fbb)
    Eppo_UFC_Variation.add(algorithmType: algorithmType, &fbb)
    return Eppo_UFC_Variation.endVariation(&fbb, start: __start)
  }
  public static func sortVectorOfVariation(offsets:[Offset], _ fbb: inout FlatBufferBuilder) -> Offset {
    var off = offsets
    off.sort { Table.compare(Table.offset(Int32($1.o), vOffset: 4, fbb: &fbb), Table.offset(Int32($0.o), vOffset: 4, fbb: &fbb), fbb: &fbb) < 0 } 
    return fbb.createVector(ofOffsets: off)
  }
  fileprivate static func lookupByKey(vector: Int32, key: String, fbb: ByteBuffer) -> Eppo_UFC_Variation? {
    let key = key.utf8.map { $0 }
    var span = fbb.read(def: Int32.self, position: Int(vector - 4))
    var start: Int32 = 0
    while span != 0 {
      var middle = span / 2
      let tableOffset = Table.indirect(vector + 4 * (start + middle), fbb)
      let comp = Table.compare(Table.offset(Int32(fbb.capacity) - tableOffset, vOffset: 4, fbb: fbb), key, fbb: fbb)
      if comp > 0 {
        span = middle
      } else if comp < 0 {
        middle += 1
        start += middle
        span -= middle
      } else {
        return Eppo_UFC_Variation(fbb, o: tableOffset)
      }
    }
    return nil
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.key.p, fieldName: "key", required: true, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.value.p, fieldName: "value", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.algorithmType.p, fieldName: "algorithmType", required: false, type: Eppo_UFC_AlgorithmType.self)
    _v.finish()
  }
}

public struct Eppo_UFC_TargetingRuleCondition: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case operator_ = 4
    case attribute = 6
    case value = 8
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var operator_: String? { let o = _accessor.offset(VTOFFSET.operator_.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var operator_SegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.operator_.v) }
  public var attribute: String? { let o = _accessor.offset(VTOFFSET.attribute.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var attributeSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.attribute.v) }
  public var value: String? { let o = _accessor.offset(VTOFFSET.value.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var valueSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.value.v) }
  public static func startTargetingRuleCondition(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
  public static func add(operator_: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: operator_, at: VTOFFSET.operator_.p) }
  public static func add(attribute: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: attribute, at: VTOFFSET.attribute.p) }
  public static func add(value: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: value, at: VTOFFSET.value.p) }
  public static func endTargetingRuleCondition(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createTargetingRuleCondition(
    _ fbb: inout FlatBufferBuilder,
    operator_Offset operator_: Offset = Offset(),
    attributeOffset attribute: Offset = Offset(),
    valueOffset value: Offset = Offset()
  ) -> Offset {
    let __start = Eppo_UFC_TargetingRuleCondition.startTargetingRuleCondition(&fbb)
    Eppo_UFC_TargetingRuleCondition.add(operator_: operator_, &fbb)
    Eppo_UFC_TargetingRuleCondition.add(attribute: attribute, &fbb)
    Eppo_UFC_TargetingRuleCondition.add(value: value, &fbb)
    return Eppo_UFC_TargetingRuleCondition.endTargetingRuleCondition(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.operator_.p, fieldName: "operator_", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.attribute.p, fieldName: "attribute", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.value.p, fieldName: "value", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

public struct Eppo_UFC_Rule: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case conditions = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var hasConditions: Bool { let o = _accessor.offset(VTOFFSET.conditions.v); return o == 0 ? false : true }
  public var conditionsCount: Int32 { let o = _accessor.offset(VTOFFSET.conditions.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func conditions(at index: Int32) -> Eppo_UFC_TargetingRuleCondition? { let o = _accessor.offset(VTOFFSET.conditions.v); return o == 0 ? nil : Eppo_UFC_TargetingRuleCondition(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startRule(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func addVectorOf(conditions: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: conditions, at: VTOFFSET.conditions.p) }
  public static func endRule(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createRule(
    _ fbb: inout FlatBufferBuilder,
    conditionsVectorOffset conditions: Offset = Offset()
  ) -> Offset {
    let __start = Eppo_UFC_Rule.startRule(&fbb)
    Eppo_UFC_Rule.addVectorOf(conditions: conditions, &fbb)
    return Eppo_UFC_Rule.endRule(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.conditions.p, fieldName: "conditions", required: false, type: ForwardOffset<Vector<ForwardOffset<Eppo_UFC_TargetingRuleCondition>, Eppo_UFC_TargetingRuleCondition>>.self)
    _v.finish()
  }
}

public struct Eppo_UFC_Allocation: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case key = 4
    case rules = 6
    case startAt = 8
    case endAt = 10
    case splits = 12
    case doLog = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var key: String? { let o = _accessor.offset(VTOFFSET.key.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var keySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.key.v) }
  public var hasRules: Bool { let o = _accessor.offset(VTOFFSET.rules.v); return o == 0 ? false : true }
  public var rulesCount: Int32 { let o = _accessor.offset(VTOFFSET.rules.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func rules(at index: Int32) -> Eppo_UFC_Rule? { let o = _accessor.offset(VTOFFSET.rules.v); return o == 0 ? nil : Eppo_UFC_Rule(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var startAt: String? { let o = _accessor.offset(VTOFFSET.startAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var startAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.startAt.v) }
  public var endAt: String? { let o = _accessor.offset(VTOFFSET.endAt.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var endAtSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.endAt.v) }
  public var hasSplits: Bool { let o = _accessor.offset(VTOFFSET.splits.v); return o == 0 ? false : true }
  public var splitsCount: Int32 { let o = _accessor.offset(VTOFFSET.splits.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func splits(at index: Int32) -> Eppo_UFC_Split? { let o = _accessor.offset(VTOFFSET.splits.v); return o == 0 ? nil : Eppo_UFC_Split(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var doLog: Bool { let o = _accessor.offset(VTOFFSET.doLog.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public static func startAllocation(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(key: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: key, at: VTOFFSET.key.p) }
  public static func addVectorOf(rules: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: rules, at: VTOFFSET.rules.p) }
  public static func add(startAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: startAt, at: VTOFFSET.startAt.p) }
  public static func add(endAt: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: endAt, at: VTOFFSET.endAt.p) }
  public static func addVectorOf(splits: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: splits, at: VTOFFSET.splits.p) }
  public static func add(doLog: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: doLog, def: false,
   at: VTOFFSET.doLog.p) }
  public static func endAllocation(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createAllocation(
    _ fbb: inout FlatBufferBuilder,
    keyOffset key: Offset = Offset(),
    rulesVectorOffset rules: Offset = Offset(),
    startAtOffset startAt: Offset = Offset(),
    endAtOffset endAt: Offset = Offset(),
    splitsVectorOffset splits: Offset = Offset(),
    doLog: Bool = false
  ) -> Offset {
    let __start = Eppo_UFC_Allocation.startAllocation(&fbb)
    Eppo_UFC_Allocation.add(key: key, &fbb)
    Eppo_UFC_Allocation.addVectorOf(rules: rules, &fbb)
    Eppo_UFC_Allocation.add(startAt: startAt, &fbb)
    Eppo_UFC_Allocation.add(endAt: endAt, &fbb)
    Eppo_UFC_Allocation.addVectorOf(splits: splits, &fbb)
    Eppo_UFC_Allocation.add(doLog: doLog, &fbb)
    return Eppo_UFC_Allocation.endAllocation(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.key.p, fieldName: "key", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.rules.p, fieldName: "rules", required: false, type: ForwardOffset<Vector<ForwardOffset<Eppo_UFC_Rule>, Eppo_UFC_Rule>>.self)
    try _v.visit(field: VTOFFSET.startAt.p, fieldName: "startAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.endAt.p, fieldName: "endAt", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.splits.p, fieldName: "splits", required: false, type: ForwardOffset<Vector<ForwardOffset<Eppo_UFC_Split>, Eppo_UFC_Split>>.self)
    try _v.visit(field: VTOFFSET.doLog.p, fieldName: "doLog", required: false, type: Bool.self)
    _v.finish()
  }
}

public struct Eppo_UFC_Flag: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case key = 4
    case enabled = 6
    case variationType = 8
    case variations = 10
    case allocations = 12
    case totalShards = 14
    case entityId = 16
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var key: String? { let o = _accessor.offset(VTOFFSET.key.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var keySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.key.v) }
  public var enabled: Bool { let o = _accessor.offset(VTOFFSET.enabled.v); return o == 0 ? false : _accessor.readBuffer(of: Bool.self, at: o) }
  public var variationType: Eppo_UFC_VariationType { let o = _accessor.offset(VTOFFSET.variationType.v); return o == 0 ? .boolean : Eppo_UFC_VariationType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .boolean }
  public var hasVariations: Bool { let o = _accessor.offset(VTOFFSET.variations.v); return o == 0 ? false : true }
  public var variationsCount: Int32 { let o = _accessor.offset(VTOFFSET.variations.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func variations(at index: Int32) -> Eppo_UFC_Variation? { let o = _accessor.offset(VTOFFSET.variations.v); return o == 0 ? nil : Eppo_UFC_Variation(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public func variationsBy(key: String) -> Eppo_UFC_Variation? { let o = _accessor.offset(VTOFFSET.variations.v); return o == 0 ? nil : Eppo_UFC_Variation.lookupByKey(vector: _accessor.vector(at: o), key: key, fbb: _accessor.bb) }
  public var hasAllocations: Bool { let o = _accessor.offset(VTOFFSET.allocations.v); return o == 0 ? false : true }
  public var allocationsCount: Int32 { let o = _accessor.offset(VTOFFSET.allocations.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func allocations(at index: Int32) -> Eppo_UFC_Allocation? { let o = _accessor.offset(VTOFFSET.allocations.v); return o == 0 ? nil : Eppo_UFC_Allocation(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public var totalShards: Int32 { let o = _accessor.offset(VTOFFSET.totalShards.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public var entityId: Int32 { let o = _accessor.offset(VTOFFSET.entityId.v); return o == 0 ? 0 : _accessor.readBuffer(of: Int32.self, at: o) }
  public static func startFlag(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 7) }
  public static func add(key: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: key, at: VTOFFSET.key.p) }
  public static func add(enabled: Bool, _ fbb: inout FlatBufferBuilder) { fbb.add(element: enabled, def: false,
   at: VTOFFSET.enabled.p) }
  public static func add(variationType: Eppo_UFC_VariationType, _ fbb: inout FlatBufferBuilder) { fbb.add(element: variationType.rawValue, def: 0, at: VTOFFSET.variationType.p) }
  public static func addVectorOf(variations: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: variations, at: VTOFFSET.variations.p) }
  public static func addVectorOf(allocations: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: allocations, at: VTOFFSET.allocations.p) }
  public static func add(totalShards: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: totalShards, def: 0, at: VTOFFSET.totalShards.p) }
  public static func add(entityId: Int32, _ fbb: inout FlatBufferBuilder) { fbb.add(element: entityId, def: 0, at: VTOFFSET.entityId.p) }
  public static func endFlag(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createFlag(
    _ fbb: inout FlatBufferBuilder,
    keyOffset key: Offset = Offset(),
    enabled: Bool = false,
    variationType: Eppo_UFC_VariationType = .boolean,
    variationsVectorOffset variations: Offset = Offset(),
    allocationsVectorOffset allocations: Offset = Offset(),
    totalShards: Int32 = 0,
    entityId: Int32 = 0
  ) -> Offset {
    let __start = Eppo_UFC_Flag.startFlag(&fbb)
    Eppo_UFC_Flag.add(key: key, &fbb)
    Eppo_UFC_Flag.add(enabled: enabled, &fbb)
    Eppo_UFC_Flag.add(variationType: variationType, &fbb)
    Eppo_UFC_Flag.addVectorOf(variations: variations, &fbb)
    Eppo_UFC_Flag.addVectorOf(allocations: allocations, &fbb)
    Eppo_UFC_Flag.add(totalShards: totalShards, &fbb)
    Eppo_UFC_Flag.add(entityId: entityId, &fbb)
    return Eppo_UFC_Flag.endFlag(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.key.p, fieldName: "key", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.enabled.p, fieldName: "enabled", required: false, type: Bool.self)
    try _v.visit(field: VTOFFSET.variationType.p, fieldName: "variationType", required: false, type: Eppo_UFC_VariationType.self)
    try _v.visit(field: VTOFFSET.variations.p, fieldName: "variations", required: false, type: ForwardOffset<Vector<ForwardOffset<Eppo_UFC_Variation>, Eppo_UFC_Variation>>.self)
    try _v.visit(field: VTOFFSET.allocations.p, fieldName: "allocations", required: false, type: ForwardOffset<Vector<ForwardOffset<Eppo_UFC_Allocation>, Eppo_UFC_Allocation>>.self)
    try _v.visit(field: VTOFFSET.totalShards.p, fieldName: "totalShards", required: false, type: Int32.self)
    try _v.visit(field: VTOFFSET.entityId.p, fieldName: "entityId", required: false, type: Int32.self)
    _v.finish()
  }
}

public struct Eppo_UFC_Environment: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case name = 4
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var name: String? { let o = _accessor.offset(VTOFFSET.name.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var nameSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.name.v) }
  public static func startEnvironment(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
  public static func add(name: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: name, at: VTOFFSET.name.p) }
  public static func endEnvironment(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createEnvironment(
    _ fbb: inout FlatBufferBuilder,
    nameOffset name: Offset = Offset()
  ) -> Offset {
    let __start = Eppo_UFC_Environment.startEnvironment(&fbb)
    Eppo_UFC_Environment.add(name: name, &fbb)
    return Eppo_UFC_Environment.endEnvironment(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.name.p, fieldName: "name", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

public struct Eppo_UFC_BanditFlagVariation: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case key = 4
    case flagKey = 6
    case allocationKey = 8
    case variationKey = 10
    case variationValue = 12
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var key: String? { let o = _accessor.offset(VTOFFSET.key.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var keySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.key.v) }
  public var flagKey: String? { let o = _accessor.offset(VTOFFSET.flagKey.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var flagKeySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.flagKey.v) }
  public var allocationKey: String? { let o = _accessor.offset(VTOFFSET.allocationKey.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var allocationKeySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.allocationKey.v) }
  public var variationKey: String? { let o = _accessor.offset(VTOFFSET.variationKey.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var variationKeySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.variationKey.v) }
  public var variationValue: String? { let o = _accessor.offset(VTOFFSET.variationValue.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var variationValueSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.variationValue.v) }
  public static func startBanditFlagVariation(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 5) }
  public static func add(key: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: key, at: VTOFFSET.key.p) }
  public static func add(flagKey: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: flagKey, at: VTOFFSET.flagKey.p) }
  public static func add(allocationKey: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: allocationKey, at: VTOFFSET.allocationKey.p) }
  public static func add(variationKey: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: variationKey, at: VTOFFSET.variationKey.p) }
  public static func add(variationValue: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: variationValue, at: VTOFFSET.variationValue.p) }
  public static func endBanditFlagVariation(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createBanditFlagVariation(
    _ fbb: inout FlatBufferBuilder,
    keyOffset key: Offset = Offset(),
    flagKeyOffset flagKey: Offset = Offset(),
    allocationKeyOffset allocationKey: Offset = Offset(),
    variationKeyOffset variationKey: Offset = Offset(),
    variationValueOffset variationValue: Offset = Offset()
  ) -> Offset {
    let __start = Eppo_UFC_BanditFlagVariation.startBanditFlagVariation(&fbb)
    Eppo_UFC_BanditFlagVariation.add(key: key, &fbb)
    Eppo_UFC_BanditFlagVariation.add(flagKey: flagKey, &fbb)
    Eppo_UFC_BanditFlagVariation.add(allocationKey: allocationKey, &fbb)
    Eppo_UFC_BanditFlagVariation.add(variationKey: variationKey, &fbb)
    Eppo_UFC_BanditFlagVariation.add(variationValue: variationValue, &fbb)
    return Eppo_UFC_BanditFlagVariation.endBanditFlagVariation(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.key.p, fieldName: "key", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.flagKey.p, fieldName: "flagKey", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.allocationKey.p, fieldName: "allocationKey", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.variationKey.p, fieldName: "variationKey", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.variationValue.p, fieldName: "variationValue", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

public struct Eppo_UFC_BanditReference: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case modelVersion = 4
    case flagVariations = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var modelVersion: String? { let o = _accessor.offset(VTOFFSET.modelVersion.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var modelVersionSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.modelVersion.v) }
  public var hasFlagVariations: Bool { let o = _accessor.offset(VTOFFSET.flagVariations.v); return o == 0 ? false : true }
  public var flagVariationsCount: Int32 { let o = _accessor.offset(VTOFFSET.flagVariations.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func flagVariations(at index: Int32) -> Eppo_UFC_BanditFlagVariation? { let o = _accessor.offset(VTOFFSET.flagVariations.v); return o == 0 ? nil : Eppo_UFC_BanditFlagVariation(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startBanditReference(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(modelVersion: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: modelVersion, at: VTOFFSET.modelVersion.p) }
  public static func addVectorOf(flagVariations: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: flagVariations, at: VTOFFSET.flagVariations.p) }
  public static func endBanditReference(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createBanditReference(
    _ fbb: inout FlatBufferBuilder,
    modelVersionOffset modelVersion: Offset = Offset(),
    flagVariationsVectorOffset flagVariations: Offset = Offset()
  ) -> Offset {
    let __start = Eppo_UFC_BanditReference.startBanditReference(&fbb)
    Eppo_UFC_BanditReference.add(modelVersion: modelVersion, &fbb)
    Eppo_UFC_BanditReference.addVectorOf(flagVariations: flagVariations, &fbb)
    return Eppo_UFC_BanditReference.endBanditReference(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.modelVersion.p, fieldName: "modelVersion", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.flagVariations.p, fieldName: "flagVariations", required: false, type: ForwardOffset<Vector<ForwardOffset<Eppo_UFC_BanditFlagVariation>, Eppo_UFC_BanditFlagVariation>>.self)
    _v.finish()
  }
}

public struct Eppo_UFC_StringPair: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case key = 4
    case value = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var key: String? { let o = _accessor.offset(VTOFFSET.key.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var keySegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.key.v) }
  public var value: String? { let o = _accessor.offset(VTOFFSET.value.v); return o == 0 ? nil : _accessor.string(at: o) }
  public var valueSegmentArray: [UInt8]? { return _accessor.getVector(at: VTOFFSET.value.v) }
  public static func startStringPair(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(key: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: key, at: VTOFFSET.key.p) }
  public static func add(value: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: value, at: VTOFFSET.value.p) }
  public static func endStringPair(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createStringPair(
    _ fbb: inout FlatBufferBuilder,
    keyOffset key: Offset = Offset(),
    valueOffset value: Offset = Offset()
  ) -> Offset {
    let __start = Eppo_UFC_StringPair.startStringPair(&fbb)
    Eppo_UFC_StringPair.add(key: key, &fbb)
    Eppo_UFC_StringPair.add(value: value, &fbb)
    return Eppo_UFC_StringPair.endStringPair(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.key.p, fieldName: "key", required: false, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.value.p, fieldName: "value", required: false, type: ForwardOffset<String>.self)
    _v.finish()
  }
}

public struct Eppo_UFC_FlagEntry: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case key = 4
    case flag = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var key: String! { let o = _accessor.offset(VTOFFSET.key.v); return _accessor.string(at: o) }
  public var keySegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.key.v) }
  public var flag: Eppo_UFC_Flag? { let o = _accessor.offset(VTOFFSET.flag.v); return o == 0 ? nil : Eppo_UFC_Flag(_accessor.bb, o: _accessor.indirect(o + _accessor.position)) }
  public static func startFlagEntry(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(key: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: key, at: VTOFFSET.key.p) }
  public static func add(flag: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: flag, at: VTOFFSET.flag.p) }
  public static func endFlagEntry(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
  public static func createFlagEntry(
    _ fbb: inout FlatBufferBuilder,
    keyOffset key: Offset,
    flagOffset flag: Offset = Offset()
  ) -> Offset {
    let __start = Eppo_UFC_FlagEntry.startFlagEntry(&fbb)
    Eppo_UFC_FlagEntry.add(key: key, &fbb)
    Eppo_UFC_FlagEntry.add(flag: flag, &fbb)
    return Eppo_UFC_FlagEntry.endFlagEntry(&fbb, start: __start)
  }
  public static func sortVectorOfFlagEntry(offsets:[Offset], _ fbb: inout FlatBufferBuilder) -> Offset {
    var off = offsets
    off.sort { Table.compare(Table.offset(Int32($1.o), vOffset: 4, fbb: &fbb), Table.offset(Int32($0.o), vOffset: 4, fbb: &fbb), fbb: &fbb) < 0 } 
    return fbb.createVector(ofOffsets: off)
  }
  fileprivate static func lookupByKey(vector: Int32, key: String, fbb: ByteBuffer) -> Eppo_UFC_FlagEntry? {
    let key = key.utf8.map { $0 }
    var span = fbb.read(def: Int32.self, position: Int(vector - 4))
    var start: Int32 = 0
    while span != 0 {
      var middle = span / 2
      let tableOffset = Table.indirect(vector + 4 * (start + middle), fbb)
      let comp = Table.compare(Table.offset(Int32(fbb.capacity) - tableOffset, vOffset: 4, fbb: fbb), key, fbb: fbb)
      if comp > 0 {
        span = middle
      } else if comp < 0 {
        middle += 1
        start += middle
        span -= middle
      } else {
        return Eppo_UFC_FlagEntry(fbb, o: tableOffset)
      }
    }
    return nil
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.key.p, fieldName: "key", required: true, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.flag.p, fieldName: "flag", required: false, type: ForwardOffset<Eppo_UFC_Flag>.self)
    _v.finish()
  }
}

public struct Eppo_UFC_BanditReferenceEntry: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case key = 4
    case banditReference = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var key: String! { let o = _accessor.offset(VTOFFSET.key.v); return _accessor.string(at: o) }
  public var keySegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.key.v) }
  public var banditReference: Eppo_UFC_BanditReference? { let o = _accessor.offset(VTOFFSET.banditReference.v); return o == 0 ? nil : Eppo_UFC_BanditReference(_accessor.bb, o: _accessor.indirect(o + _accessor.position)) }
  public static func startBanditReferenceEntry(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(key: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: key, at: VTOFFSET.key.p) }
  public static func add(banditReference: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: banditReference, at: VTOFFSET.banditReference.p) }
  public static func endBanditReferenceEntry(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
  public static func createBanditReferenceEntry(
    _ fbb: inout FlatBufferBuilder,
    keyOffset key: Offset,
    banditReferenceOffset banditReference: Offset = Offset()
  ) -> Offset {
    let __start = Eppo_UFC_BanditReferenceEntry.startBanditReferenceEntry(&fbb)
    Eppo_UFC_BanditReferenceEntry.add(key: key, &fbb)
    Eppo_UFC_BanditReferenceEntry.add(banditReference: banditReference, &fbb)
    return Eppo_UFC_BanditReferenceEntry.endBanditReferenceEntry(&fbb, start: __start)
  }
  public static func sortVectorOfBanditReferenceEntry(offsets:[Offset], _ fbb: inout FlatBufferBuilder) -> Offset {
    var off = offsets
    off.sort { Table.compare(Table.offset(Int32($1.o), vOffset: 4, fbb: &fbb), Table.offset(Int32($0.o), vOffset: 4, fbb: &fbb), fbb: &fbb) < 0 } 
    return fbb.createVector(ofOffsets: off)
  }
  fileprivate static func lookupByKey(vector: Int32, key: String, fbb: ByteBuffer) -> Eppo_UFC_BanditReferenceEntry? {
    let key = key.utf8.map { $0 }
    var span = fbb.read(def: Int32.self, position: Int(vector - 4))
    var start: Int32 = 0
    while span != 0 {
      var middle = span / 2
      let tableOffset = Table.indirect(vector + 4 * (start + middle), fbb)
      let comp = Table.compare(Table.offset(Int32(fbb.capacity) - tableOffset, vOffset: 4, fbb: fbb), key, fbb: fbb)
      if comp > 0 {
        span = middle
      } else if comp < 0 {
        middle += 1
        start += middle
        span -= middle
      } else {
        return Eppo_UFC_BanditReferenceEntry(fbb, o: tableOffset)
      }
    }
    return nil
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.key.p, fieldName: "key", required: true, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.banditReference.p, fieldName: "banditReference", required: false, type: ForwardOffset<Eppo_UFC_BanditReference>.self)
    _v.finish()
  }
}

public struct Eppo_UFC_BanditFlagVariationEntry: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case key = 4
    case variations = 6
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var key: String! { let o = _accessor.offset(VTOFFSET.key.v); return _accessor.string(at: o) }
  public var keySegmentArray: [UInt8]! { return _accessor.getVector(at: VTOFFSET.key.v) }
  public var hasVariations: Bool { let o = _accessor.offset(VTOFFSET.variations.v); return o == 0 ? false : true }
  public var variationsCount: Int32 { let o = _accessor.offset(VTOFFSET.variations.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func variations(at index: Int32) -> Eppo_UFC_BanditFlagVariation? { let o = _accessor.offset(VTOFFSET.variations.v); return o == 0 ? nil : Eppo_UFC_BanditFlagVariation(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public static func startBanditFlagVariationEntry(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
  public static func add(key: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: key, at: VTOFFSET.key.p) }
  public static func addVectorOf(variations: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: variations, at: VTOFFSET.variations.p) }
  public static func endBanditFlagVariationEntry(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); fbb.require(table: end, fields: [4]); return end }
  public static func createBanditFlagVariationEntry(
    _ fbb: inout FlatBufferBuilder,
    keyOffset key: Offset,
    variationsVectorOffset variations: Offset = Offset()
  ) -> Offset {
    let __start = Eppo_UFC_BanditFlagVariationEntry.startBanditFlagVariationEntry(&fbb)
    Eppo_UFC_BanditFlagVariationEntry.add(key: key, &fbb)
    Eppo_UFC_BanditFlagVariationEntry.addVectorOf(variations: variations, &fbb)
    return Eppo_UFC_BanditFlagVariationEntry.endBanditFlagVariationEntry(&fbb, start: __start)
  }
  public static func sortVectorOfBanditFlagVariationEntry(offsets:[Offset], _ fbb: inout FlatBufferBuilder) -> Offset {
    var off = offsets
    off.sort { Table.compare(Table.offset(Int32($1.o), vOffset: 4, fbb: &fbb), Table.offset(Int32($0.o), vOffset: 4, fbb: &fbb), fbb: &fbb) < 0 } 
    return fbb.createVector(ofOffsets: off)
  }
  fileprivate static func lookupByKey(vector: Int32, key: String, fbb: ByteBuffer) -> Eppo_UFC_BanditFlagVariationEntry? {
    let key = key.utf8.map { $0 }
    var span = fbb.read(def: Int32.self, position: Int(vector - 4))
    var start: Int32 = 0
    while span != 0 {
      var middle = span / 2
      let tableOffset = Table.indirect(vector + 4 * (start + middle), fbb)
      let comp = Table.compare(Table.offset(Int32(fbb.capacity) - tableOffset, vOffset: 4, fbb: fbb), key, fbb: fbb)
      if comp > 0 {
        span = middle
      } else if comp < 0 {
        middle += 1
        start += middle
        span -= middle
      } else {
        return Eppo_UFC_BanditFlagVariationEntry(fbb, o: tableOffset)
      }
    }
    return nil
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.key.p, fieldName: "key", required: true, type: ForwardOffset<String>.self)
    try _v.visit(field: VTOFFSET.variations.p, fieldName: "variations", required: false, type: ForwardOffset<Vector<ForwardOffset<Eppo_UFC_BanditFlagVariation>, Eppo_UFC_BanditFlagVariation>>.self)
    _v.finish()
  }
}

public struct Eppo_UFC_UniversalFlagConfig: FlatBufferObject, Verifiable {

  static func validateVersion() { FlatBuffersVersion_25_9_23() }
  public var __buffer: ByteBuffer! { return _accessor.bb }
  private var _accessor: Table

  private init(_ t: Table) { _accessor = t }
  public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

  private enum VTOFFSET: VOffset {
    case createdAt = 4
    case format = 6
    case environment = 8
    case flags = 10
    case banditReferences = 12
    case bandits = 14
    var v: Int32 { Int32(self.rawValue) }
    var p: VOffset { self.rawValue }
  }

  public var createdAt: UInt64 { let o = _accessor.offset(VTOFFSET.createdAt.v); return o == 0 ? 0 : _accessor.readBuffer(of: UInt64.self, at: o) }
  public var format: Eppo_UFC_UFCFormat { let o = _accessor.offset(VTOFFSET.format.v); return o == 0 ? .server : Eppo_UFC_UFCFormat(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .server }
  public var environment: Eppo_UFC_Environment? { let o = _accessor.offset(VTOFFSET.environment.v); return o == 0 ? nil : Eppo_UFC_Environment(_accessor.bb, o: _accessor.indirect(o + _accessor.position)) }
  public var hasFlags: Bool { let o = _accessor.offset(VTOFFSET.flags.v); return o == 0 ? false : true }
  public var flagsCount: Int32 { let o = _accessor.offset(VTOFFSET.flags.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func flags(at index: Int32) -> Eppo_UFC_FlagEntry? { let o = _accessor.offset(VTOFFSET.flags.v); return o == 0 ? nil : Eppo_UFC_FlagEntry(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public func flagsBy(key: String) -> Eppo_UFC_FlagEntry? { let o = _accessor.offset(VTOFFSET.flags.v); return o == 0 ? nil : Eppo_UFC_FlagEntry.lookupByKey(vector: _accessor.vector(at: o), key: key, fbb: _accessor.bb) }
  public var hasBanditReferences: Bool { let o = _accessor.offset(VTOFFSET.banditReferences.v); return o == 0 ? false : true }
  public var banditReferencesCount: Int32 { let o = _accessor.offset(VTOFFSET.banditReferences.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func banditReferences(at index: Int32) -> Eppo_UFC_BanditReferenceEntry? { let o = _accessor.offset(VTOFFSET.banditReferences.v); return o == 0 ? nil : Eppo_UFC_BanditReferenceEntry(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public func banditReferencesBy(key: String) -> Eppo_UFC_BanditReferenceEntry? { let o = _accessor.offset(VTOFFSET.banditReferences.v); return o == 0 ? nil : Eppo_UFC_BanditReferenceEntry.lookupByKey(vector: _accessor.vector(at: o), key: key, fbb: _accessor.bb) }
  public var hasBandits: Bool { let o = _accessor.offset(VTOFFSET.bandits.v); return o == 0 ? false : true }
  public var banditsCount: Int32 { let o = _accessor.offset(VTOFFSET.bandits.v); return o == 0 ? 0 : _accessor.vector(count: o) }
  public func bandits(at index: Int32) -> Eppo_UFC_BanditFlagVariationEntry? { let o = _accessor.offset(VTOFFSET.bandits.v); return o == 0 ? nil : Eppo_UFC_BanditFlagVariationEntry(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
  public func banditsBy(key: String) -> Eppo_UFC_BanditFlagVariationEntry? { let o = _accessor.offset(VTOFFSET.bandits.v); return o == 0 ? nil : Eppo_UFC_BanditFlagVariationEntry.lookupByKey(vector: _accessor.vector(at: o), key: key, fbb: _accessor.bb) }
  public static func startUniversalFlagConfig(_ fbb: inout FlatBufferBuilder) -> UOffset { fbb.startTable(with: 6) }
  public static func add(createdAt: UInt64, _ fbb: inout FlatBufferBuilder) { fbb.add(element: createdAt, def: 0, at: VTOFFSET.createdAt.p) }
  public static func add(format: Eppo_UFC_UFCFormat, _ fbb: inout FlatBufferBuilder) { fbb.add(element: format.rawValue, def: 0, at: VTOFFSET.format.p) }
  public static func add(environment: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: environment, at: VTOFFSET.environment.p) }
  public static func addVectorOf(flags: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: flags, at: VTOFFSET.flags.p) }
  public static func addVectorOf(banditReferences: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: banditReferences, at: VTOFFSET.banditReferences.p) }
  public static func addVectorOf(bandits: Offset, _ fbb: inout FlatBufferBuilder) { fbb.add(offset: bandits, at: VTOFFSET.bandits.p) }
  public static func endUniversalFlagConfig(_ fbb: inout FlatBufferBuilder, start: UOffset) -> Offset { let end = Offset(offset: fbb.endTable(at: start)); return end }
  public static func createUniversalFlagConfig(
    _ fbb: inout FlatBufferBuilder,
    createdAt: UInt64 = 0,
    format: Eppo_UFC_UFCFormat = .server,
    environmentOffset environment: Offset = Offset(),
    flagsVectorOffset flags: Offset = Offset(),
    banditReferencesVectorOffset banditReferences: Offset = Offset(),
    banditsVectorOffset bandits: Offset = Offset()
  ) -> Offset {
    let __start = Eppo_UFC_UniversalFlagConfig.startUniversalFlagConfig(&fbb)
    Eppo_UFC_UniversalFlagConfig.add(createdAt: createdAt, &fbb)
    Eppo_UFC_UniversalFlagConfig.add(format: format, &fbb)
    Eppo_UFC_UniversalFlagConfig.add(environment: environment, &fbb)
    Eppo_UFC_UniversalFlagConfig.addVectorOf(flags: flags, &fbb)
    Eppo_UFC_UniversalFlagConfig.addVectorOf(banditReferences: banditReferences, &fbb)
    Eppo_UFC_UniversalFlagConfig.addVectorOf(bandits: bandits, &fbb)
    return Eppo_UFC_UniversalFlagConfig.endUniversalFlagConfig(&fbb, start: __start)
  }

  public static func verify<T>(_ verifier: inout Verifier, at position: Int, of type: T.Type) throws where T: Verifiable {
    var _v = try verifier.visitTable(at: position)
    try _v.visit(field: VTOFFSET.createdAt.p, fieldName: "createdAt", required: false, type: UInt64.self)
    try _v.visit(field: VTOFFSET.format.p, fieldName: "format", required: false, type: Eppo_UFC_UFCFormat.self)
    try _v.visit(field: VTOFFSET.environment.p, fieldName: "environment", required: false, type: ForwardOffset<Eppo_UFC_Environment>.self)
    try _v.visit(field: VTOFFSET.flags.p, fieldName: "flags", required: false, type: ForwardOffset<Vector<ForwardOffset<Eppo_UFC_FlagEntry>, Eppo_UFC_FlagEntry>>.self)
    try _v.visit(field: VTOFFSET.banditReferences.p, fieldName: "banditReferences", required: false, type: ForwardOffset<Vector<ForwardOffset<Eppo_UFC_BanditReferenceEntry>, Eppo_UFC_BanditReferenceEntry>>.self)
    try _v.visit(field: VTOFFSET.bandits.p, fieldName: "bandits", required: false, type: ForwardOffset<Vector<ForwardOffset<Eppo_UFC_BanditFlagVariationEntry>, Eppo_UFC_BanditFlagVariationEntry>>.self)
    _v.finish()
  }
}

