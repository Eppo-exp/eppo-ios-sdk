// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ufc.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Eppo_Ufc_UFCFormat: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case server // = 0
  case client // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .server
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .server
    case 1: self = .client
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .server: return 0
    case .client: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Eppo_Ufc_UFCFormat] = [
    .server,
    .client,
  ]

}

enum Eppo_Ufc_VariationType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case boolean // = 0
  case integer // = 1
  case json // = 2
  case numeric // = 3
  case string // = 4
  case UNRECOGNIZED(Int)

  init() {
    self = .boolean
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .boolean
    case 1: self = .integer
    case 2: self = .json
    case 3: self = .numeric
    case 4: self = .string
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .boolean: return 0
    case .integer: return 1
    case .json: return 2
    case .numeric: return 3
    case .string: return 4
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Eppo_Ufc_VariationType] = [
    .boolean,
    .integer,
    .json,
    .numeric,
    .string,
  ]

}

enum Eppo_Ufc_OperatorType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case matches // = 0
  case notMatches // = 1
  case gte // = 2
  case gt // = 3
  case lte // = 4
  case lt // = 5
  case oneOf // = 6
  case notOneOf // = 7
  case isNull // = 8
  case UNRECOGNIZED(Int)

  init() {
    self = .matches
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .matches
    case 1: self = .notMatches
    case 2: self = .gte
    case 3: self = .gt
    case 4: self = .lte
    case 5: self = .lt
    case 6: self = .oneOf
    case 7: self = .notOneOf
    case 8: self = .isNull
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .matches: return 0
    case .notMatches: return 1
    case .gte: return 2
    case .gt: return 3
    case .lte: return 4
    case .lt: return 5
    case .oneOf: return 6
    case .notOneOf: return 7
    case .isNull: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Eppo_Ufc_OperatorType] = [
    .matches,
    .notMatches,
    .gte,
    .gt,
    .lte,
    .lt,
    .oneOf,
    .notOneOf,
    .isNull,
  ]

}

enum Eppo_Ufc_AlgorithmType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case constant // = 0
  case contextualBandit // = 1
  case UNRECOGNIZED(Int)

  init() {
    self = .constant
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .constant
    case 1: self = .contextualBandit
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .constant: return 0
    case .contextualBandit: return 1
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Eppo_Ufc_AlgorithmType] = [
    .constant,
    .contextualBandit,
  ]

}

struct Eppo_Ufc_Range: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// inclusive
  var start: Int32 = 0

  /// exclusive
  var end: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Eppo_Ufc_Shard: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var salt: String = String()

  var ranges: [Eppo_Ufc_Range] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Eppo_Ufc_Split: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var variationKey: String = String()

  var shards: [Eppo_Ufc_Shard] = []

  /// Optional key-value pairs
  var extraLogging: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Eppo_Ufc_Variation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Indexed for fast lookup
  var key: String = String()

  /// JSON-encoded value
  var value: String = String()

  var algorithmType: Eppo_Ufc_AlgorithmType = .constant

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Eppo_Ufc_TargetingRuleCondition: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Enum for fast comparison
  var `operator`: Eppo_Ufc_OperatorType = .matches

  /// User-defined attribute name
  var attribute: String = String()

  /// JSON-encoded value
  var value: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Eppo_Ufc_Rule: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var conditions: [Eppo_Ufc_TargetingRuleCondition] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Eppo_Ufc_Allocation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  /// Optional targeting rules
  var rules: [Eppo_Ufc_Rule] = []

  /// Optional Unix timestamp in milliseconds
  var startAt: UInt64 = 0

  /// Optional Unix timestamp in milliseconds
  var endAt: UInt64 = 0

  var splits: [Eppo_Ufc_Split] = []

  var doLog: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Eppo_Ufc_Flag: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var enabled: Bool = false

  var variationType: Eppo_Ufc_VariationType = .boolean

  /// Sorted by key for fast lookup
  var variations: [Eppo_Ufc_Variation] = []

  var allocations: [Eppo_Ufc_Allocation] = []

  var totalShards: Int32 = 0

  /// Optional, default 0
  var entityID: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Eppo_Ufc_Environment: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Eppo_Ufc_BanditFlagVariation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var flagKey: String = String()

  var allocationKey: String = String()

  var variationKey: String = String()

  var variationValue: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Eppo_Ufc_BanditReference: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Optional
  var modelVersion: String = String()

  var flagVariations: [Eppo_Ufc_BanditFlagVariation] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Root message - the main UFC structure
struct Eppo_Ufc_UniversalFlagConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unix timestamp in milliseconds
  var createdAt: UInt64 = 0

  var format: Eppo_Ufc_UFCFormat = .server

  var environment: Eppo_Ufc_Environment {
    get {return _environment ?? Eppo_Ufc_Environment()}
    set {_environment = newValue}
  }
  /// Returns true if `environment` has been explicitly set.
  var hasEnvironment: Bool {return self._environment != nil}
  /// Clears the value of `environment`. Subsequent reads from it will return its default value.
  mutating func clearEnvironment() {self._environment = nil}

  /// Map of flag key to flag object
  var flags: Dictionary<String,Eppo_Ufc_Flag> = [:]

  /// Optional bandit references
  var banditReferences: Dictionary<String,Eppo_Ufc_BanditReference> = [:]

  /// Deprecated - legacy bandit support
  var bandits: Dictionary<String,Eppo_Ufc_BanditFlagVariation> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _environment: Eppo_Ufc_Environment? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "eppo.ufc"

extension Eppo_Ufc_UFCFormat: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SERVER\0\u{1}CLIENT\0")
}

extension Eppo_Ufc_VariationType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0BOOLEAN\0\u{1}INTEGER\0\u{1}JSON\0\u{1}NUMERIC\0\u{1}STRING\0")
}

extension Eppo_Ufc_OperatorType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0MATCHES\0\u{1}NOT_MATCHES\0\u{1}GTE\0\u{1}GT\0\u{1}LTE\0\u{1}LT\0\u{1}ONE_OF\0\u{1}NOT_ONE_OF\0\u{1}IS_NULL\0")
}

extension Eppo_Ufc_AlgorithmType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0CONSTANT\0\u{1}CONTEXTUAL_BANDIT\0")
}

extension Eppo_Ufc_Range: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Range"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}start\0\u{1}end\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.start) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.end) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.start != 0 {
      try visitor.visitSingularInt32Field(value: self.start, fieldNumber: 1)
    }
    if self.end != 0 {
      try visitor.visitSingularInt32Field(value: self.end, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Eppo_Ufc_Range, rhs: Eppo_Ufc_Range) -> Bool {
    if lhs.start != rhs.start {return false}
    if lhs.end != rhs.end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eppo_Ufc_Shard: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Shard"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}salt\0\u{1}ranges\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.salt) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.ranges) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.salt.isEmpty {
      try visitor.visitSingularStringField(value: self.salt, fieldNumber: 1)
    }
    if !self.ranges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ranges, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Eppo_Ufc_Shard, rhs: Eppo_Ufc_Shard) -> Bool {
    if lhs.salt != rhs.salt {return false}
    if lhs.ranges != rhs.ranges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eppo_Ufc_Split: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Split"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}variation_key\0\u{1}shards\0\u{3}extra_logging\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.variationKey) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.shards) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.extraLogging) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.variationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.variationKey, fieldNumber: 1)
    }
    if !self.shards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.shards, fieldNumber: 2)
    }
    if !self.extraLogging.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.extraLogging, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Eppo_Ufc_Split, rhs: Eppo_Ufc_Split) -> Bool {
    if lhs.variationKey != rhs.variationKey {return false}
    if lhs.shards != rhs.shards {return false}
    if lhs.extraLogging != rhs.extraLogging {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eppo_Ufc_Variation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Variation"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0\u{1}value\0\u{3}algorithm_type\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.value) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.algorithmType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 2)
    }
    if self.algorithmType != .constant {
      try visitor.visitSingularEnumField(value: self.algorithmType, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Eppo_Ufc_Variation, rhs: Eppo_Ufc_Variation) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs.algorithmType != rhs.algorithmType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eppo_Ufc_TargetingRuleCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TargetingRuleCondition"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}operator\0\u{1}attribute\0\u{1}value\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.`operator`) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.attribute) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.value) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.`operator` != .matches {
      try visitor.visitSingularEnumField(value: self.`operator`, fieldNumber: 1)
    }
    if !self.attribute.isEmpty {
      try visitor.visitSingularStringField(value: self.attribute, fieldNumber: 2)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularStringField(value: self.value, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Eppo_Ufc_TargetingRuleCondition, rhs: Eppo_Ufc_TargetingRuleCondition) -> Bool {
    if lhs.`operator` != rhs.`operator` {return false}
    if lhs.attribute != rhs.attribute {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eppo_Ufc_Rule: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Rule"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}conditions\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.conditions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conditions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conditions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Eppo_Ufc_Rule, rhs: Eppo_Ufc_Rule) -> Bool {
    if lhs.conditions != rhs.conditions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eppo_Ufc_Allocation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Allocation"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0\u{1}rules\0\u{3}start_at\0\u{3}end_at\0\u{1}splits\0\u{3}do_log\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.rules) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.startAt) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.endAt) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.splits) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.doLog) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.rules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rules, fieldNumber: 2)
    }
    if self.startAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.startAt, fieldNumber: 3)
    }
    if self.endAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.endAt, fieldNumber: 4)
    }
    if !self.splits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.splits, fieldNumber: 5)
    }
    if self.doLog != false {
      try visitor.visitSingularBoolField(value: self.doLog, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Eppo_Ufc_Allocation, rhs: Eppo_Ufc_Allocation) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.rules != rhs.rules {return false}
    if lhs.startAt != rhs.startAt {return false}
    if lhs.endAt != rhs.endAt {return false}
    if lhs.splits != rhs.splits {return false}
    if lhs.doLog != rhs.doLog {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eppo_Ufc_Flag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Flag"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0\u{1}enabled\0\u{3}variation_type\0\u{1}variations\0\u{1}allocations\0\u{3}total_shards\0\u{3}entity_id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.variationType) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.variations) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.allocations) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.totalShards) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.entityID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 2)
    }
    if self.variationType != .boolean {
      try visitor.visitSingularEnumField(value: self.variationType, fieldNumber: 3)
    }
    if !self.variations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.variations, fieldNumber: 4)
    }
    if !self.allocations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.allocations, fieldNumber: 5)
    }
    if self.totalShards != 0 {
      try visitor.visitSingularInt32Field(value: self.totalShards, fieldNumber: 6)
    }
    if self.entityID != 0 {
      try visitor.visitSingularInt32Field(value: self.entityID, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Eppo_Ufc_Flag, rhs: Eppo_Ufc_Flag) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.variationType != rhs.variationType {return false}
    if lhs.variations != rhs.variations {return false}
    if lhs.allocations != rhs.allocations {return false}
    if lhs.totalShards != rhs.totalShards {return false}
    if lhs.entityID != rhs.entityID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eppo_Ufc_Environment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Environment"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Eppo_Ufc_Environment, rhs: Eppo_Ufc_Environment) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eppo_Ufc_BanditFlagVariation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BanditFlagVariation"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0\u{3}flag_key\0\u{3}allocation_key\0\u{3}variation_key\0\u{3}variation_value\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.flagKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.allocationKey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.variationKey) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.variationValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.flagKey.isEmpty {
      try visitor.visitSingularStringField(value: self.flagKey, fieldNumber: 2)
    }
    if !self.allocationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.allocationKey, fieldNumber: 3)
    }
    if !self.variationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.variationKey, fieldNumber: 4)
    }
    if !self.variationValue.isEmpty {
      try visitor.visitSingularStringField(value: self.variationValue, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Eppo_Ufc_BanditFlagVariation, rhs: Eppo_Ufc_BanditFlagVariation) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.flagKey != rhs.flagKey {return false}
    if lhs.allocationKey != rhs.allocationKey {return false}
    if lhs.variationKey != rhs.variationKey {return false}
    if lhs.variationValue != rhs.variationValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eppo_Ufc_BanditReference: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BanditReference"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}model_version\0\u{3}flag_variations\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.modelVersion) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.flagVariations) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.modelVersion.isEmpty {
      try visitor.visitSingularStringField(value: self.modelVersion, fieldNumber: 1)
    }
    if !self.flagVariations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.flagVariations, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Eppo_Ufc_BanditReference, rhs: Eppo_Ufc_BanditReference) -> Bool {
    if lhs.modelVersion != rhs.modelVersion {return false}
    if lhs.flagVariations != rhs.flagVariations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Eppo_Ufc_UniversalFlagConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UniversalFlagConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}created_at\0\u{1}format\0\u{1}environment\0\u{1}flags\0\u{3}bandit_references\0\u{1}bandits\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.createdAt) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._environment) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Eppo_Ufc_Flag>.self, value: &self.flags) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Eppo_Ufc_BanditReference>.self, value: &self.banditReferences) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Eppo_Ufc_BanditFlagVariation>.self, value: &self.bandits) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.createdAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.createdAt, fieldNumber: 1)
    }
    if self.format != .server {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 2)
    }
    try { if let v = self._environment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.flags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Eppo_Ufc_Flag>.self, value: self.flags, fieldNumber: 4)
    }
    if !self.banditReferences.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Eppo_Ufc_BanditReference>.self, value: self.banditReferences, fieldNumber: 5)
    }
    if !self.bandits.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Eppo_Ufc_BanditFlagVariation>.self, value: self.bandits, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Eppo_Ufc_UniversalFlagConfig, rhs: Eppo_Ufc_UniversalFlagConfig) -> Bool {
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs.format != rhs.format {return false}
    if lhs._environment != rhs._environment {return false}
    if lhs.flags != rhs.flags {return false}
    if lhs.banditReferences != rhs.banditReferences {return false}
    if lhs.bandits != rhs.bandits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
