// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ufc.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Ufc_UFCFormat: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int

  /// Required zero value for proto3
  case unspecified // = 0
  case server // = 1
  case client // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .unspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unspecified
    case 1: self = .server
    case 2: self = .client
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .unspecified: return 0
    case .server: return 1
    case .client: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Ufc_UFCFormat] = [
    .unspecified,
    .server,
    .client,
  ]

}

enum Ufc_ExperimentVariationValueType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int

  /// Required zero value for proto3
  case variationValueTypeUnspecified // = 0
  case boolean // = 1
  case integer // = 2
  case numeric // = 3
  case string // = 4
  case json // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .variationValueTypeUnspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .variationValueTypeUnspecified
    case 1: self = .boolean
    case 2: self = .integer
    case 3: self = .numeric
    case 4: self = .string
    case 5: self = .json
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .variationValueTypeUnspecified: return 0
    case .boolean: return 1
    case .integer: return 2
    case .numeric: return 3
    case .string: return 4
    case .json: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Ufc_ExperimentVariationValueType] = [
    .variationValueTypeUnspecified,
    .boolean,
    .integer,
    .numeric,
    .string,
    .json,
  ]

}

enum Ufc_ExperimentVariationAlgorithmType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int

  /// Required zero value for proto3
  case algorithmTypeUnspecified // = 0
  case constant // = 1
  case contextualBandit // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .algorithmTypeUnspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .algorithmTypeUnspecified
    case 1: self = .constant
    case 2: self = .contextualBandit
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .algorithmTypeUnspecified: return 0
    case .constant: return 1
    case .contextualBandit: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Ufc_ExperimentVariationAlgorithmType] = [
    .algorithmTypeUnspecified,
    .constant,
    .contextualBandit,
  ]

}

/// Universal Flag Configuration - main message
struct Ufc_UniversalFlagConfig: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Milliseconds since Unix epoch
  var createdAtMs: Int64 = 0

  var format: Ufc_UFCFormat = .unspecified

  var environment: Ufc_EnvironmentDto {
    get {return _environment ?? Ufc_EnvironmentDto()}
    set {_environment = newValue}
  }
  /// Returns true if `environment` has been explicitly set.
  var hasEnvironment: Bool {return self._environment != nil}
  /// Clears the value of `environment`. Subsequent reads from it will return its default value.
  mutating func clearEnvironment() {self._environment = nil}

  var flags: Dictionary<String,Ufc_FlagDto> = [:]

  var banditReferences: Dictionary<String,Ufc_BanditReferenceDto> = [:]

  /// Deprecated field for backward compatibility
  var bandits: Dictionary<String,Ufc_BanditFlagVariations> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _environment: Ufc_EnvironmentDto? = nil
}

/// Environment information
struct Ufc_EnvironmentDto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Feature flag definition
struct Ufc_FlagDto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var enabled: Bool = false

  var variationType: Ufc_ExperimentVariationValueType = .variationValueTypeUnspecified

  var variations: Dictionary<String,Ufc_VariationDto> = [:]

  var allocations: [Ufc_AllocationDto] = []

  var totalShards: Int32 = 0

  var entityID: Int32 {
    get {return _entityID ?? 0}
    set {_entityID = newValue}
  }
  /// Returns true if `entityID` has been explicitly set.
  var hasEntityID: Bool {return self._entityID != nil}
  /// Clears the value of `entityID`. Subsequent reads from it will return its default value.
  mutating func clearEntityID() {self._entityID = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _entityID: Int32? = nil
}

/// Variation definition
struct Ufc_VariationDto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  /// Using oneof to handle union type (boolean | number | string)
  var value: Ufc_VariationDto.OneOf_Value? = nil

  var boolValue: Bool {
    get {
      if case .boolValue(let v)? = value {return v}
      return false
    }
    set {value = .boolValue(newValue)}
  }

  var numberValue: Double {
    get {
      if case .numberValue(let v)? = value {return v}
      return 0
    }
    set {value = .numberValue(newValue)}
  }

  var stringValue: String {
    get {
      if case .stringValue(let v)? = value {return v}
      return String()
    }
    set {value = .stringValue(newValue)}
  }

  var algorithmType: Ufc_ExperimentVariationAlgorithmType {
    get {return _algorithmType ?? .algorithmTypeUnspecified}
    set {_algorithmType = newValue}
  }
  /// Returns true if `algorithmType` has been explicitly set.
  var hasAlgorithmType: Bool {return self._algorithmType != nil}
  /// Clears the value of `algorithmType`. Subsequent reads from it will return its default value.
  mutating func clearAlgorithmType() {self._algorithmType = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Using oneof to handle union type (boolean | number | string)
  enum OneOf_Value: Equatable, Sendable {
    case boolValue(Bool)
    case numberValue(Double)
    case stringValue(String)

  }

  init() {}

  fileprivate var _algorithmType: Ufc_ExperimentVariationAlgorithmType? = nil
}

/// Allocation definition
struct Ufc_AllocationDto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var rules: [Ufc_RuleDto] = []

  /// Milliseconds since Unix epoch
  var startAtMs: Int64 {
    get {return _startAtMs ?? 0}
    set {_startAtMs = newValue}
  }
  /// Returns true if `startAtMs` has been explicitly set.
  var hasStartAtMs: Bool {return self._startAtMs != nil}
  /// Clears the value of `startAtMs`. Subsequent reads from it will return its default value.
  mutating func clearStartAtMs() {self._startAtMs = nil}

  /// Milliseconds since Unix epoch
  var endAtMs: Int64 {
    get {return _endAtMs ?? 0}
    set {_endAtMs = newValue}
  }
  /// Returns true if `endAtMs` has been explicitly set.
  var hasEndAtMs: Bool {return self._endAtMs != nil}
  /// Clears the value of `endAtMs`. Subsequent reads from it will return its default value.
  mutating func clearEndAtMs() {self._endAtMs = nil}

  var splits: [Ufc_SplitDto] = []

  var doLog: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _startAtMs: Int64? = nil
  fileprivate var _endAtMs: Int64? = nil
}

/// Targeting rule
struct Ufc_RuleDto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var conditions: [Ufc_TargetingRuleCondition] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Split definition
struct Ufc_SplitDto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var variationKey: String = String()

  var shards: [Ufc_ShardDto] = []

  var extraLogging: Dictionary<String,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Shard definition
struct Ufc_ShardDto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var salt: String = String()

  var ranges: [Ufc_RangeDto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Range definition (inclusive start, exclusive end)
struct Ufc_RangeDto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// inclusive
  var start: Int32 = 0

  /// exclusive
  var end: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Targeting rule condition
struct Ufc_TargetingRuleCondition: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var `operator`: String = String()

  var attribute: String = String()

  /// Using oneof to handle union type (number | boolean | string | string[])
  var value: Ufc_TargetingRuleCondition.OneOf_Value? = nil

  var numberValue: Double {
    get {
      if case .numberValue(let v)? = value {return v}
      return 0
    }
    set {value = .numberValue(newValue)}
  }

  var boolValue: Bool {
    get {
      if case .boolValue(let v)? = value {return v}
      return false
    }
    set {value = .boolValue(newValue)}
  }

  var stringValue: String {
    get {
      if case .stringValue(let v)? = value {return v}
      return String()
    }
    set {value = .stringValue(newValue)}
  }

  var stringArrayValue: Ufc_StringArray {
    get {
      if case .stringArrayValue(let v)? = value {return v}
      return Ufc_StringArray()
    }
    set {value = .stringArrayValue(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// Using oneof to handle union type (number | boolean | string | string[])
  enum OneOf_Value: Equatable, Sendable {
    case numberValue(Double)
    case boolValue(Bool)
    case stringValue(String)
    case stringArrayValue(Ufc_StringArray)

  }

  init() {}
}

/// Helper message for string arrays
struct Ufc_StringArray: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var values: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Bandit flag variation (deprecated but kept for compatibility)
struct Ufc_BanditFlagVariationDto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var flagKey: String = String()

  var allocationKey: String = String()

  var variationKey: String = String()

  var variationValue: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Collection of bandit flag variations (for deprecated bandits field)
struct Ufc_BanditFlagVariations: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var variations: [Ufc_BanditFlagVariationDto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Bandit reference
struct Ufc_BanditReferenceDto: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var modelVersion: String {
    get {return _modelVersion ?? String()}
    set {_modelVersion = newValue}
  }
  /// Returns true if `modelVersion` has been explicitly set.
  var hasModelVersion: Bool {return self._modelVersion != nil}
  /// Clears the value of `modelVersion`. Subsequent reads from it will return its default value.
  mutating func clearModelVersion() {self._modelVersion = nil}

  var flagVariations: [Ufc_BanditFlagVariationDto] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _modelVersion: String? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ufc"

extension Ufc_UFCFormat: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0UFC_FORMAT_UNSPECIFIED\0\u{1}SERVER\0\u{1}CLIENT\0")
}

extension Ufc_ExperimentVariationValueType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0VARIATION_VALUE_TYPE_UNSPECIFIED\0\u{1}BOOLEAN\0\u{1}INTEGER\0\u{1}NUMERIC\0\u{1}STRING\0\u{1}JSON\0")
}

extension Ufc_ExperimentVariationAlgorithmType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ALGORITHM_TYPE_UNSPECIFIED\0\u{1}CONSTANT\0\u{1}CONTEXTUAL_BANDIT\0")
}

extension Ufc_UniversalFlagConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UniversalFlagConfig"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}created_at_ms\0\u{1}format\0\u{1}environment\0\u{1}flags\0\u{3}bandit_references\0\u{1}bandits\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.createdAtMs) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.format) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._environment) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Ufc_FlagDto>.self, value: &self.flags) }()
      case 5: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Ufc_BanditReferenceDto>.self, value: &self.banditReferences) }()
      case 6: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Ufc_BanditFlagVariations>.self, value: &self.bandits) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.createdAtMs != 0 {
      try visitor.visitSingularInt64Field(value: self.createdAtMs, fieldNumber: 1)
    }
    if self.format != .unspecified {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 2)
    }
    try { if let v = self._environment {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    if !self.flags.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Ufc_FlagDto>.self, value: self.flags, fieldNumber: 4)
    }
    if !self.banditReferences.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Ufc_BanditReferenceDto>.self, value: self.banditReferences, fieldNumber: 5)
    }
    if !self.bandits.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Ufc_BanditFlagVariations>.self, value: self.bandits, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ufc_UniversalFlagConfig, rhs: Ufc_UniversalFlagConfig) -> Bool {
    if lhs.createdAtMs != rhs.createdAtMs {return false}
    if lhs.format != rhs.format {return false}
    if lhs._environment != rhs._environment {return false}
    if lhs.flags != rhs.flags {return false}
    if lhs.banditReferences != rhs.banditReferences {return false}
    if lhs.bandits != rhs.bandits {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ufc_EnvironmentDto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EnvironmentDto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}name\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ufc_EnvironmentDto, rhs: Ufc_EnvironmentDto) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ufc_FlagDto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FlagDto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0\u{1}enabled\0\u{3}variation_type\0\u{1}variations\0\u{1}allocations\0\u{3}total_shards\0\u{3}entity_id\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self.variationType) }()
      case 4: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Ufc_VariationDto>.self, value: &self.variations) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.allocations) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.totalShards) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self._entityID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 2)
    }
    if self.variationType != .variationValueTypeUnspecified {
      try visitor.visitSingularEnumField(value: self.variationType, fieldNumber: 3)
    }
    if !self.variations.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufString,Ufc_VariationDto>.self, value: self.variations, fieldNumber: 4)
    }
    if !self.allocations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.allocations, fieldNumber: 5)
    }
    if self.totalShards != 0 {
      try visitor.visitSingularInt32Field(value: self.totalShards, fieldNumber: 6)
    }
    try { if let v = self._entityID {
      try visitor.visitSingularInt32Field(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ufc_FlagDto, rhs: Ufc_FlagDto) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.variationType != rhs.variationType {return false}
    if lhs.variations != rhs.variations {return false}
    if lhs.allocations != rhs.allocations {return false}
    if lhs.totalShards != rhs.totalShards {return false}
    if lhs._entityID != rhs._entityID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ufc_VariationDto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VariationDto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0\u{3}bool_value\0\u{3}number_value\0\u{3}string_value\0\u{3}algorithm_type\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .boolValue(v)
        }
      }()
      case 3: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .numberValue(v)
        }
      }()
      case 4: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .stringValue(v)
        }
      }()
      case 5: try { try decoder.decodeSingularEnumField(value: &self._algorithmType) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    switch self.value {
    case .boolValue?: try {
      guard case .boolValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case .numberValue?: try {
      guard case .numberValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    }()
    case .stringValue?: try {
      guard case .stringValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try { if let v = self._algorithmType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ufc_VariationDto, rhs: Ufc_VariationDto) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs._algorithmType != rhs._algorithmType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ufc_AllocationDto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AllocationDto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0\u{1}rules\0\u{3}start_at_ms\0\u{3}end_at_ms\0\u{1}splits\0\u{3}do_log\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.rules) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self._startAtMs) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self._endAtMs) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.splits) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.doLog) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.rules.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rules, fieldNumber: 2)
    }
    try { if let v = self._startAtMs {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._endAtMs {
      try visitor.visitSingularInt64Field(value: v, fieldNumber: 4)
    } }()
    if !self.splits.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.splits, fieldNumber: 5)
    }
    if self.doLog != false {
      try visitor.visitSingularBoolField(value: self.doLog, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ufc_AllocationDto, rhs: Ufc_AllocationDto) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.rules != rhs.rules {return false}
    if lhs._startAtMs != rhs._startAtMs {return false}
    if lhs._endAtMs != rhs._endAtMs {return false}
    if lhs.splits != rhs.splits {return false}
    if lhs.doLog != rhs.doLog {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ufc_RuleDto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RuleDto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}conditions\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.conditions) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.conditions.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.conditions, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ufc_RuleDto, rhs: Ufc_RuleDto) -> Bool {
    if lhs.conditions != rhs.conditions {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ufc_SplitDto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SplitDto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}variation_key\0\u{1}shards\0\u{3}extra_logging\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.variationKey) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.shards) }()
      case 3: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: &self.extraLogging) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.variationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.variationKey, fieldNumber: 1)
    }
    if !self.shards.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.shards, fieldNumber: 2)
    }
    if !self.extraLogging.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString,SwiftProtobuf.ProtobufString>.self, value: self.extraLogging, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ufc_SplitDto, rhs: Ufc_SplitDto) -> Bool {
    if lhs.variationKey != rhs.variationKey {return false}
    if lhs.shards != rhs.shards {return false}
    if lhs.extraLogging != rhs.extraLogging {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ufc_ShardDto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ShardDto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}salt\0\u{1}ranges\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.salt) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.ranges) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.salt.isEmpty {
      try visitor.visitSingularStringField(value: self.salt, fieldNumber: 1)
    }
    if !self.ranges.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ranges, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ufc_ShardDto, rhs: Ufc_ShardDto) -> Bool {
    if lhs.salt != rhs.salt {return false}
    if lhs.ranges != rhs.ranges {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ufc_RangeDto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RangeDto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}start\0\u{1}end\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.start) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.end) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.start != 0 {
      try visitor.visitSingularInt32Field(value: self.start, fieldNumber: 1)
    }
    if self.end != 0 {
      try visitor.visitSingularInt32Field(value: self.end, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ufc_RangeDto, rhs: Ufc_RangeDto) -> Bool {
    if lhs.start != rhs.start {return false}
    if lhs.end != rhs.end {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ufc_TargetingRuleCondition: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TargetingRuleCondition"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}operator\0\u{1}attribute\0\u{3}number_value\0\u{3}bool_value\0\u{3}string_value\0\u{3}string_array_value\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.`operator`) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.attribute) }()
      case 3: try {
        var v: Double?
        try decoder.decodeSingularDoubleField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .numberValue(v)
        }
      }()
      case 4: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .boolValue(v)
        }
      }()
      case 5: try {
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {
          if self.value != nil {try decoder.handleConflictingOneOf()}
          self.value = .stringValue(v)
        }
      }()
      case 6: try {
        var v: Ufc_StringArray?
        var hadOneofValue = false
        if let current = self.value {
          hadOneofValue = true
          if case .stringArrayValue(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.value = .stringArrayValue(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.`operator`.isEmpty {
      try visitor.visitSingularStringField(value: self.`operator`, fieldNumber: 1)
    }
    if !self.attribute.isEmpty {
      try visitor.visitSingularStringField(value: self.attribute, fieldNumber: 2)
    }
    switch self.value {
    case .numberValue?: try {
      guard case .numberValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularDoubleField(value: v, fieldNumber: 3)
    }()
    case .boolValue?: try {
      guard case .boolValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }()
    case .stringValue?: try {
      guard case .stringValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    }()
    case .stringArrayValue?: try {
      guard case .stringArrayValue(let v)? = self.value else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ufc_TargetingRuleCondition, rhs: Ufc_TargetingRuleCondition) -> Bool {
    if lhs.`operator` != rhs.`operator` {return false}
    if lhs.attribute != rhs.attribute {return false}
    if lhs.value != rhs.value {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ufc_StringArray: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".StringArray"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}values\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedStringField(value: &self.values) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.values.isEmpty {
      try visitor.visitRepeatedStringField(value: self.values, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ufc_StringArray, rhs: Ufc_StringArray) -> Bool {
    if lhs.values != rhs.values {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ufc_BanditFlagVariationDto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BanditFlagVariationDto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}key\0\u{3}flag_key\0\u{3}allocation_key\0\u{3}variation_key\0\u{3}variation_value\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.flagKey) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.allocationKey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.variationKey) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.variationValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.flagKey.isEmpty {
      try visitor.visitSingularStringField(value: self.flagKey, fieldNumber: 2)
    }
    if !self.allocationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.allocationKey, fieldNumber: 3)
    }
    if !self.variationKey.isEmpty {
      try visitor.visitSingularStringField(value: self.variationKey, fieldNumber: 4)
    }
    if !self.variationValue.isEmpty {
      try visitor.visitSingularStringField(value: self.variationValue, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ufc_BanditFlagVariationDto, rhs: Ufc_BanditFlagVariationDto) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.flagKey != rhs.flagKey {return false}
    if lhs.allocationKey != rhs.allocationKey {return false}
    if lhs.variationKey != rhs.variationKey {return false}
    if lhs.variationValue != rhs.variationValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ufc_BanditFlagVariations: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BanditFlagVariations"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}variations\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.variations) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.variations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.variations, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ufc_BanditFlagVariations, rhs: Ufc_BanditFlagVariations) -> Bool {
    if lhs.variations != rhs.variations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ufc_BanditReferenceDto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BanditReferenceDto"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}model_version\0\u{3}flag_variations\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._modelVersion) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.flagVariations) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._modelVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.flagVariations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.flagVariations, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ufc_BanditReferenceDto, rhs: Ufc_BanditReferenceDto) -> Bool {
    if lhs._modelVersion != rhs._modelVersion {return false}
    if lhs.flagVariations != rhs.flagVariations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
