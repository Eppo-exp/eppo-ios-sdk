Test Suite 'Selected tests' started at 2025-10-30 17:06:53.037.
Test Suite 'EppoFlaggingPackageTests.xctest' started at 2025-10-30 17:06:53.037.
Test Suite 'MultiwayLoadTest' started at 2025-10-30 17:06:53.037.
Test Case '-[EppoFlaggingTests.MultiwayLoadTest testFlatBufferLazyEvaluatorPerformance]' started.
ğŸ“¦ 5. Testing Swift Struct Evaluator (Lazy FlatBuffer)...

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âš¡ SWIFT STRUCTS: FlatBuffer â†’ Swift Objects Evaluator
ğŸ“Š What's tested: FlatBuffer parsing â†’ Swift struct conversion â†’ evaluation
ğŸ”¬ Startup hypothesis: SLOW - FlatBuffer parsing + Swift struct conversion overhead
ğŸ”¬ Evaluation hypothesis: EXCELLENT - Fast Swift struct access patterns
ğŸ’¾ Memory hypothesis: HIGH - All flags as Swift objects, most compact source format
ğŸ¯ Use case: Most compact serialization with Swift struct benefits
âœ… Benefits: Ultra-compact wire format, zero-copy parsing potential, type safety
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   âš¡ Startup: 8ms (FlatBuffer parsed only - lazy swift struct conversion)
   ğŸ”¥ First iteration (warming up caches/parsing)...
      -> 216 evals in 1ms = 146,135 evals/sec
   ğŸ’¨ Iteration 2 (cached performance)...
      -> 216 evals in 1ms = 160,946 evals/sec
   ğŸ’¨ Iteration 3 (cached performance)...
      -> 216 evals in 1ms = 163,267 evals/sec
   ğŸ Lazy FlatBuffer TOTAL: 53,749 evals/sec (648 evals in 12ms over 3 iterations)
   âœ… Lazy FlatBuffer test completed: 8ms startup, 53,749 evals/sec
Test Case '-[EppoFlaggingTests.MultiwayLoadTest testFlatBufferLazyEvaluatorPerformance]' passed (0.024 seconds).
Test Case '-[EppoFlaggingTests.MultiwayLoadTest testFlatBufferPrewarmedEvaluatorPerformance]' started.
ğŸ“¦ 6. Testing Swift Struct Evaluator (FlatBuffer init)...
   ğŸ”„ Pre-converting flags to UFC objects...
   âœ… Pre-converted flags successfully

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
âš¡ SWIFT STRUCTS: FlatBuffer â†’ Swift Objects Evaluator
ğŸ“Š What's tested: FlatBuffer parsing â†’ Swift struct conversion â†’ evaluation
ğŸ”¬ Startup hypothesis: SLOW - FlatBuffer parsing + Swift struct conversion overhead
ğŸ”¬ Evaluation hypothesis: EXCELLENT - Fast Swift struct access patterns
ğŸ’¾ Memory hypothesis: HIGH - All flags as Swift objects, most compact source format
ğŸ¯ Use case: Most compact serialization with Swift struct benefits
âœ… Benefits: Ultra-compact wire format, zero-copy parsing potential, type safety
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   âš¡ Startup: 519ms (swift structs populated from FlatBuffer)
   ğŸ”¥ First iteration (warming up caches/parsing)...
      -> 216 evals in 0ms = 1,911,328 evals/sec
   ğŸ’¨ Iteration 2 (cached performance)...
      -> 216 evals in 0ms = 1,999,933 evals/sec
   ğŸ’¨ Iteration 3 (cached performance)...
      -> 216 evals in 0ms = 1,982,428 evals/sec
   ğŸ FlatBuffer init TOTAL: 185,674 evals/sec (648 evals in 3ms over 3 iterations)
   âœ… FlatBuffer init test completed: 519ms startup, 185,674 evals/sec
Test Case '-[EppoFlaggingTests.MultiwayLoadTest testFlatBufferPrewarmedEvaluatorPerformance]' passed (0.535 seconds).
Test Case '-[EppoFlaggingTests.MultiwayLoadTest testJSONEvaluatorPerformance]' started.
ğŸ“¦ 1. Testing Swift Struct Evaluator (JSON init)...

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ›ï¸  BASELINE: Traditional JSON Configuration Evaluator
ğŸ“Š What's tested: JSON parsing â†’ Swift struct conversion â†’ evaluation
ğŸ”¬ Startup hypothesis: SLOWEST - Full JSON parsing and object creation overhead
ğŸ”¬ Evaluation hypothesis: GOOD - Optimized Swift struct access patterns
ğŸ’¾ Memory hypothesis: HIGH - All flags converted to Swift objects in memory
ğŸ¯ Use case: Traditional approach, good for comparison baseline
âœ… Benefits: Mature, well-tested, human-readable config format
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   âš¡ Startup: 2,137ms (swift structs populated from JSON - 10000 flags)
   ğŸ”¥ First iteration (warming up caches/parsing)...
      -> 216 evals in 0ms = 488,656 evals/sec
   ğŸ’¨ Iteration 2 (cached performance)...
      -> 216 evals in 0ms = 536,076 evals/sec
   ğŸ’¨ Iteration 3 (cached performance)...
      -> 216 evals in 0ms = 534,653 evals/sec
   ğŸ JSON TOTAL: 128,061 evals/sec (648 evals in 5ms over 3 iterations)
   âœ… JSON test completed: 2,137ms startup, 128,061 evals/sec
Test Case '-[EppoFlaggingTests.MultiwayLoadTest testJSONEvaluatorPerformance]' passed (2.177 seconds).
Test Case '-[EppoFlaggingTests.MultiwayLoadTest testNativeFlatBufferNoIndexEvaluatorPerformance]' started.
ğŸ“¦ 9. Testing Native FlatBuffer Evaluator (BLOCKING - Parse FlatBuffer Only)...
   â³ BLOCKING until FlatBuffer parsing completes...
   âœ… BLOCKED - FlatBuffer parsed and ready, O(log n) flag lookup

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸš€ NATIVE: Direct FlatBuffer Binary Evaluator (NO SWIFT STRUCTS)
ğŸ“Š What's tested: Direct FlatBuffer binary evaluation with optional O(1) indexing
ğŸ”¬ Startup hypothesis: FASTEST - Zero-copy access, optional index building
ğŸ”¬ Evaluation hypothesis: FASTEST - O(1) lookup with index, zero allocations
ğŸ’¾ Memory hypothesis: LOWEST - Raw binary format, absolute minimal allocation
ğŸ¯ Use case: Performance-critical applications, maximum throughput required
âœ… Benefits: Ultimate performance potential, zero-copy access, optional O(1) vs O(log n) trade-off
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   âš¡ Startup: 0ms (BLOCKING - FlatBuffer parsed, ready for O(log n) evaluation)
   ğŸ”¥ First iteration (warming up caches/parsing)...
      -> 216 evals in 1ms = 181,502 evals/sec
   ğŸ’¨ Iteration 2 (cached performance)...
      -> 216 evals in 1ms = 179,702 evals/sec
   ğŸ’¨ Iteration 3 (cached performance)...
      -> 216 evals in 1ms = 188,979 evals/sec
   ğŸ Native FB No Index TOTAL: 90,895 evals/sec (648 evals in 7ms over 3 iterations)
   âœ… Native FB No Index test completed: 0ms startup, 90,895 evals/sec
Test Case '-[EppoFlaggingTests.MultiwayLoadTest testNativeFlatBufferNoIndexEvaluatorPerformance]' passed (0.008 seconds).
Test Case '-[EppoFlaggingTests.MultiwayLoadTest testNativeFlatBufferWithIndexEvaluatorPerformance]' started.
ğŸ“¦ 10. Testing Native FlatBuffer Evaluator (BLOCKING - Parse + Build O(1) Index)...
   â³ BLOCKING until FlatBuffer parsing AND O(1) index building completes...
   âœ… BLOCKED - FlatBuffer parsed + O(1) index built, ready for fastest evaluation

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸš€ NATIVE: Direct FlatBuffer Binary Evaluator (NO SWIFT STRUCTS)
ğŸ“Š What's tested: Direct FlatBuffer binary evaluation with optional O(1) indexing
ğŸ”¬ Startup hypothesis: FASTEST - Zero-copy access, optional index building
ğŸ”¬ Evaluation hypothesis: FASTEST - O(1) lookup with index, zero allocations
ğŸ’¾ Memory hypothesis: LOWEST - Raw binary format, absolute minimal allocation
ğŸ¯ Use case: Performance-critical applications, maximum throughput required
âœ… Benefits: Ultimate performance potential, zero-copy access, optional O(1) vs O(log n) trade-off
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   âš¡ Startup: 9ms (BLOCKING - FlatBuffer parsed + O(1) index built, ready for ultra-fast evaluation)
   ğŸ”¥ First iteration (warming up caches/parsing)...
      -> 216 evals in 0ms = 1,449,551 evals/sec
   ğŸ’¨ Iteration 2 (cached performance)...
      -> 216 evals in 0ms = 1,531,647 evals/sec
   ğŸ’¨ Iteration 3 (cached performance)...
      -> 216 evals in 0ms = 1,635,324 evals/sec
   ğŸ Native FB With Index TOTAL: 161,674 evals/sec (648 evals in 4ms over 3 iterations)
   âœ… Native FB With Index test completed: 9ms startup, 161,674 evals/sec
Test Case '-[EppoFlaggingTests.MultiwayLoadTest testNativeFlatBufferWithIndexEvaluatorPerformance]' passed (0.014 seconds).
Test Case '-[EppoFlaggingTests.MultiwayLoadTest testNativeProtobufLazyEvaluatorPerformance]' started.
ğŸ“¦ 7. Testing Native Protobuf Evaluator (LAZY - Parse on First Access)...

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ”¥ NATIVE: Direct Protobuf Binary Evaluator (NO SWIFT STRUCTS)
ğŸ“Š What's tested: Direct protobuf binary evaluation without object conversion
ğŸ”¬ Startup hypothesis: VERY FAST - No Swift struct creation, binary ready
ğŸ”¬ Evaluation hypothesis: GOOD - Direct binary access, no object overhead
ğŸ’¾ Memory hypothesis: LOW - Raw binary format, minimal memory allocation
ğŸ¯ Use case: Memory-constrained environments, ultra-fast startup required
âœ… Benefits: Minimal memory footprint, lightning startup, no GC pressure
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   âš¡ Startup: 0ms (LAZY - protobuf parsing deferred until first evaluation)
   ğŸ”¥ First iteration (warming up caches/parsing)...
      -> 216 evals in 793ms = 272 evals/sec
   ğŸ’¨ Iteration 2 (cached performance)...
      -> 216 evals in 0ms = 1,488,857 evals/sec
   ğŸ’¨ Iteration 3 (cached performance)...
      -> 216 evals in 0ms = 1,458,888 evals/sec
   ğŸ Native PB Lazy TOTAL: 812 evals/sec (648 evals in 797ms over 3 iterations)
   âœ… Native PB Lazy test completed: 0ms startup, 812 evals/sec
Test Case '-[EppoFlaggingTests.MultiwayLoadTest testNativeProtobufLazyEvaluatorPerformance]' passed (0.810 seconds).
Test Case '-[EppoFlaggingTests.MultiwayLoadTest testNativeProtobufPrewarmedEvaluatorPerformance]' started.
ğŸ“¦ 8. Testing Native Protobuf Evaluator (BLOCKING - Parse All Upfront)...
   â³ BLOCKING until all protobuf parsing completes...
   âœ… BLOCKED - all flags parsed and ready for evaluation

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ”¥ NATIVE: Direct Protobuf Binary Evaluator (NO SWIFT STRUCTS)
ğŸ“Š What's tested: Direct protobuf binary evaluation without object conversion
ğŸ”¬ Startup hypothesis: VERY FAST - No Swift struct creation, binary ready
ğŸ”¬ Evaluation hypothesis: GOOD - Direct binary access, no object overhead
ğŸ’¾ Memory hypothesis: LOW - Raw binary format, minimal memory allocation
ğŸ¯ Use case: Memory-constrained environments, ultra-fast startup required
âœ… Benefits: Minimal memory footprint, lightning startup, no GC pressure
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   âš¡ Startup: 810ms (BLOCKING - protobuf fully parsed upfront, objects ready)
   ğŸ”¥ First iteration (warming up caches/parsing)...
      -> 216 evals in 0ms = 1,333,288 evals/sec
   ğŸ’¨ Iteration 2 (cached performance)...
      -> 216 evals in 0ms = 1,469,537 evals/sec
   ğŸ’¨ Iteration 3 (cached performance)...
      -> 216 evals in 0ms = 1,469,537 evals/sec
   ğŸ Native PB Prewarmed TOTAL: 138,938 evals/sec (648 evals in 4ms over 3 iterations)
   âœ… Native PB Prewarmed test completed: 810ms startup, 138,938 evals/sec
Test Case '-[EppoFlaggingTests.MultiwayLoadTest testNativeProtobufPrewarmedEvaluatorPerformance]' passed (0.828 seconds).
Test Case '-[EppoFlaggingTests.MultiwayLoadTest testProtobufLazyEvaluatorPerformance]' started.
ğŸ“¦ 3. Testing Swift Struct Evaluator (Lazy PB)...

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“¦ SWIFT STRUCTS: Protobuf â†’ Swift Objects Evaluator
ğŸ“Š What's tested: Protobuf parsing â†’ Swift struct conversion â†’ evaluation
ğŸ”¬ Startup hypothesis: SLOW - Protobuf parsing + Swift struct conversion overhead
ğŸ”¬ Evaluation hypothesis: EXCELLENT - Fast Swift struct access patterns
ğŸ’¾ Memory hypothesis: HIGH - All flags as Swift objects, more compact source than JSON
ğŸ¯ Use case: Balanced approach with better serialization than JSON
âœ… Benefits: Compact wire format, type safety, should be faster than JSON startup
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   âš¡ Startup: 731ms (protobuf parsed only - lazy swift struct conversion)
   ğŸ”¥ First iteration (warming up caches/parsing)...
      -> 216 evals in 0ms = 877,877 evals/sec
   ğŸ’¨ Iteration 2 (cached performance)...
      -> 216 evals in 0ms = 938,828 evals/sec
   ğŸ’¨ Iteration 3 (cached performance)...
      -> 216 evals in 0ms = 896,112 evals/sec
   ğŸ Lazy PB TOTAL: 160,395 evals/sec (648 evals in 4ms over 3 iterations)
   âœ… Lazy PB test completed: 731ms startup, 160,395 evals/sec
Test Case '-[EppoFlaggingTests.MultiwayLoadTest testProtobufLazyEvaluatorPerformance]' passed (0.748 seconds).
Test Case '-[EppoFlaggingTests.MultiwayLoadTest testProtobufPrewarmedEvaluatorPerformance]' started.
ğŸ“¦ 4. Testing Swift Struct Evaluator (Protobuf init)...
   ğŸ”„ Pre-converting flags to UFC objects...
   âœ… Pre-converted flags successfully

â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
ğŸ“¦ SWIFT STRUCTS: Protobuf â†’ Swift Objects Evaluator
ğŸ“Š What's tested: Protobuf parsing â†’ Swift struct conversion â†’ evaluation
ğŸ”¬ Startup hypothesis: SLOW - Protobuf parsing + Swift struct conversion overhead
ğŸ”¬ Evaluation hypothesis: EXCELLENT - Fast Swift struct access patterns
ğŸ’¾ Memory hypothesis: HIGH - All flags as Swift objects, more compact source than JSON
ğŸ¯ Use case: Balanced approach with better serialization than JSON
âœ… Benefits: Compact wire format, type safety, should be faster than JSON startup
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
   âš¡ Startup: 819ms (swift structs populated from protobuf)
   ğŸ”¥ First iteration (warming up caches/parsing)...
      -> 216 evals in 0ms = 1,742,249 evals/sec
   ğŸ’¨ Iteration 2 (cached performance)...
      -> 216 evals in 0ms = 1,911,328 evals/sec
   ğŸ’¨ Iteration 3 (cached performance)...
      -> 216 evals in 0ms = 1,895,334 evals/sec
   ğŸ Protobuf init TOTAL: 141,576 evals/sec (648 evals in 4ms over 3 iterations)
   âœ… Protobuf init test completed: 819ms startup, 141,576 evals/sec
Test Case '-[EppoFlaggingTests.MultiwayLoadTest testProtobufPrewarmedEvaluatorPerformance]' passed (0.847 seconds).
Test Case '-[EppoFlaggingTests.MultiwayLoadTest testZZZPerformanceComparison]' started.

============================================================
ğŸ† CROSS-EVALUATOR PERFORMANCE COMPARISON
============================================================
ğŸ“Š Results Summary:
   â€¢ FlatBuffer init: 519ms startup, 185,674 evals/sec
   â€¢ JSON: 2,137ms startup, 128,061 evals/sec
   â€¢ Lazy FlatBuffer: 8ms startup, 53,749 evals/sec
   â€¢ Lazy PB: 731ms startup, 160,395 evals/sec
   â€¢ Native FB No Index: 0ms startup, 90,895 evals/sec
   â€¢ Native FB With Index: 9ms startup, 161,674 evals/sec
   â€¢ Native PB Lazy: 0ms startup, 812 evals/sec
   â€¢ Native PB Prewarmed: 810ms startup, 138,938 evals/sec
   â€¢ Protobuf init: 819ms startup, 141,576 evals/sec

âš¡ STARTUP SPEED RANKINGS:
   1. Native PB Lazy: 0ms
   2. Native FB No Index: 0ms
   3. Lazy FlatBuffer: 8ms
   4. Native FB With Index: 9ms
   5. FlatBuffer init: 519ms
   6. Lazy PB: 731ms
   7. Native PB Prewarmed: 810ms
   8. Protobuf init: 819ms
   9. JSON: 2,137ms

ğŸš€ EVALUATION SPEED RANKINGS:
   1. FlatBuffer init: 185,674 evals/sec
   2. Native FB With Index: 161,674 evals/sec
   3. Lazy PB: 160,395 evals/sec
   4. Protobuf init: 141,576 evals/sec
   5. Native PB Prewarmed: 138,938 evals/sec
   6. JSON: 128,061 evals/sec
   7. Native FB No Index: 90,895 evals/sec
   8. Lazy FlatBuffer: 53,749 evals/sec
   9. Native PB Lazy: 812 evals/sec

ğŸ“ˆ SPEEDUP vs JSON BASELINE:
   â€¢ FlatBuffer init: 4.1x startup, 1.4x evaluation
   â€¢ Native FB With Index: 223.4x startup, 1.3x evaluation
   â€¢ Lazy PB: 2.9x startup, 1.3x evaluation
   â€¢ Protobuf init: 2.6x startup, 1.1x evaluation
   â€¢ Native PB Prewarmed: 2.6x startup, 1.1x evaluation
   â€¢ JSON: 1.0x startup, 1.0x evaluation
   â€¢ Native FB No Index: 213489.6x startup, 0.7x evaluation
   â€¢ Lazy FlatBuffer: 250.1x startup, 0.4x evaluation
   â€¢ Native PB Lazy: 351629.9x startup, 0.0x evaluation

ğŸ¥Š NATIVE vs SWIFT STRUCT AVERAGES:
   Native Avg: 205ms startup, 98,080 evals/sec
   Swift Avg:  843ms startup, 133,891 evals/sec
   Native wins by: 4.1x startup, 0.7x evaluation

ğŸ“¦ FLATBUFFER INDEX ANALYSIS:
   Index Build Cost: +9ms
   Index Speed Gain: 1.8x faster evaluation
   Trade-off: Pay 9ms once for 1.8x ongoing performance

âœ… Performance comparison completed!
ğŸ’¾ Memory benefit: Each test ran in isolation with automatic cleanup between tests
Test Case '-[EppoFlaggingTests.MultiwayLoadTest testZZZPerformanceComparison]' passed (0.001 seconds).
Test Suite 'MultiwayLoadTest' passed at 2025-10-30 17:06:59.032.
	 Executed 10 tests, with 0 failures (0 unexpected) in 5.993 (5.994) seconds
Test Suite 'EppoFlaggingPackageTests.xctest' passed at 2025-10-30 17:06:59.032.
	 Executed 10 tests, with 0 failures (0 unexpected) in 5.993 (5.994) seconds
Test Suite 'Selected tests' passed at 2025-10-30 17:06:59.032.
	 Executed 10 tests, with 0 failures (0 unexpected) in 5.993 (5.995) seconds
   ğŸ”„ Pre-converting 10000 flags to UFC objects...
   âœ… Pre-converted 10000 flags successfully
   ğŸ“š Building FlatBuffer flag index for 10000 flags...
   âœ… Built index for 10000 flags
   ğŸ”„ Pre-parsed protobuf config: 10000 flags
   ğŸ”„ Pre-converting 10000 flags to UFC objects...
   âœ… Pre-converted 10000 flags successfully
â—‡ Test run started.
â†³ Testing Library Version: 1085
â†³ Target Platform: arm64e-apple-macos14.0
âœ” Test run with 0 tests in 0 suites passed after 0.001 seconds.
